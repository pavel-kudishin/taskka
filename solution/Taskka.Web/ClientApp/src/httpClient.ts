/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.1.0.0 (NJsonSchema v9.13.28.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class Client {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl ? baseUrl : "";
	}

	/**
	 * @return Success
	 */
	getBoard(): Promise<BoardDto> {
		let url_ = this.baseUrl + "/api/Data/GetBoard";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				"Accept": "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetBoard(_response);
		});
	}

	protected processGetBoard(response: Response): Promise<BoardDto> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = resultData200 ? BoardDto.fromJS(resultData200) : new BoardDto();
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<BoardDto>(<any>null);
	}

	/**
	 * @param taskId (optional) 
	 * @param priority (optional) 
	 * @param statusId (optional) 
	 * @return Success
	 */
	updateTask(taskId: number | null | undefined, priority: number | null | undefined, statusId: number | null | undefined): Promise<void> {
		let url_ = this.baseUrl + "/api/Data/UpdateTask?";
		if (taskId !== undefined)
			url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
		if (priority !== undefined)
			url_ += "priority=" + encodeURIComponent("" + priority) + "&";
		if (statusId !== undefined)
			url_ += "statusId=" + encodeURIComponent("" + statusId) + "&";
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "POST",
			headers: {
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processUpdateTask(_response);
		});
	}

	protected processUpdateTask(response: Response): Promise<void> {
		const status = response.status;
		let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
		if (status === 200) {
			return response.text().then((_responseText) => {
				return;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException("An unexpected server error occurred.", status, _responseText, _headers);
			});
		}
		return Promise.resolve<void>(<any>null);
	}
}

export class BoardDto implements IBoardDto {
	statuses!: StatusDto[];
	tasks!: TaskDto[];

	constructor(data?: IBoardDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
		if (!data) {
			this.statuses = [];
			this.tasks = [];
		}
	}

	init(data?: any) {
		if (data) {
			if (data["statuses"] && data["statuses"].constructor === Array) {
				this.statuses = [] as any;
				for (let item of data["statuses"])
					this.statuses!.push(StatusDto.fromJS(item));
			}
			if (data["tasks"] && data["tasks"].constructor === Array) {
				this.tasks = [] as any;
				for (let item of data["tasks"])
					this.tasks!.push(TaskDto.fromJS(item));
			}
		}
	}

	static fromJS(data: any): BoardDto {
		data = typeof data === 'object' ? data : {};
		let result = new BoardDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		if (this.statuses && this.statuses.constructor === Array) {
			data["statuses"] = [];
			for (let item of this.statuses)
				data["statuses"].push(item.toJSON());
		}
		if (this.tasks && this.tasks.constructor === Array) {
			data["tasks"] = [];
			for (let item of this.tasks)
				data["tasks"].push(item.toJSON());
		}
		return data;
	}
}

export interface IBoardDto {
	statuses: StatusDto[];
	tasks: TaskDto[];
}

export class StatusDto implements IStatusDto {
	id!: number;
	title!: string;

	constructor(data?: IStatusDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(data?: any) {
		if (data) {
			this.id = data["id"];
			this.title = data["title"];
		}
	}

	static fromJS(data: any): StatusDto {
		data = typeof data === 'object' ? data : {};
		let result = new StatusDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["title"] = this.title;
		return data;
	}
}

export interface IStatusDto {
	id: number;
	title: string;
}

export class TaskDto implements ITaskDto {
	id!: number;
	title!: string;
	priority!: number;
	statusId!: number;

	constructor(data?: ITaskDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(data?: any) {
		if (data) {
			this.id = data["id"];
			this.title = data["title"];
			this.priority = data["priority"];
			this.statusId = data["statusId"];
		}
	}

	static fromJS(data: any): TaskDto {
		data = typeof data === 'object' ? data : {};
		let result = new TaskDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data["id"] = this.id;
		data["title"] = this.title;
		data["priority"] = this.priority;
		data["statusId"] = this.statusId;
		return data;
	}
}

export interface ITaskDto {
	id: number;
	title: string;
	priority: number;
	statusId: number;
}

export class SwaggerException extends Error {
	message: string;
	status: number;
	response: string;
	headers: { [key: string]: any; };
	result: any;

	constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
		super();

		this.message = message;
		this.status = status;
		this.response = response;
		this.headers = headers;
		this.result = result;
	}

	protected isSwaggerException = true;

	static isSwaggerException(obj: any): obj is SwaggerException {
		return obj.isSwaggerException === true;
	}
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
	if (result !== null && result !== undefined)
		throw result;
	else
		throw new SwaggerException(message, status, response, headers, null);
}